#
# addon egressgateways configuration
#
enabled: false

# Standalone istio egress gateway.
# Should be installed in a separate namespace, to minimize access to config
name: istio-egressgateway
ports:
- port: 80
  targetPort: 8080
  name: http2
  protocol: TCP
- port: 443
  name: https
  targetPort: 8443
  protocol: TCP

labels:
  app: istio-egressgateway
  istio: egressgateway

# Scalability tuning
# replicaCount: 1
rollingMaxSurge: 100%
rollingMaxUnavailable: 25%
autoscaleEnabled: true
autoscaleMin: 1
autoscaleMax: 5
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 2000m
    memory: 1024Mi
cpu:
  targetAverageUtilization: 80

serviceAnnotations: {}
podAnnotations: {}
type: ClusterIP # change to NodePort or LoadBalancer if need be

secretVolumes:
- name: egressgateway-certs
  secretName: istio-egressgateway-certs
  mountPath: /etc/istio/egressgateway-certs
- name: egressgateway-ca-certs
  secretName: istio-egressgateway-ca-certs
  mountPath: /etc/istio/egressgateway-ca-certs

configVolumes: []
additionalContainers: []

serviceAccount:
  # Annotations to add to the service account
  annotations: {}

### Advanced options ############
# TODO: convert to real options, env should not be exposed
env: {}
  # Set this to "external" if and only if you want the egress gateway to
  # act as a transparent SNI gateway that routes mTLS/TLS traffic to
  # external services defined using service entries, where the service
  # entry has resolution set to DNS, has one or more endpoints with
  # network field set to "external". By default its set to "" so that
  # the egress gateway sees the same set of endpoints as the sidecars
  # preserving backward compatibility
  # ISTIO_META_REQUESTED_NETWORK_VIEW: ""

nodeSelector: {}
tolerations: []

# Specify the pod anti-affinity that allows you to constrain which nodes
# your pod is eligible to be scheduled based on labels on pods that are
# already running on the node rather than based on labels on nodes.
# There are currently two types of anti-affinity:
#    "requiredDuringSchedulingIgnoredDuringExecution"
#    "preferredDuringSchedulingIgnoredDuringExecution"
# which denote "hard" vs. "soft" requirements, you can define your values
# in "podAntiAffinityLabelSelector" and "podAntiAffinityTermLabelSelector"
# correspondingly.
# For example:
# podAntiAffinityLabelSelector:
# - key: security
#   operator: In
#   values: S1,S2
#   topologyKey: "kubernetes.io/hostname"
# This pod anti-affinity rule says that the pod requires not to be scheduled
# onto a node if that node is already running a pod with label having key
# "security" and value "S1".
podAntiAffinityLabelSelector: []
podAntiAffinityTermLabelSelector: []

# whether to run the gateway in a privileged container
runAsRoot: false

# The injection template to use for the gateway. If not set, no injection will be performed.
injectionTemplate: ""

# Revision is set as 'version' label and part of the resource names when installing multiple control planes.
revision: ""

# For Helm compatibility.
ownerName: ""

meshConfig:
  enablePrometheusMerge: true

  # The trust domain corresponds to the trust root of a system
  # Refer to https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md#21-trust-domain
  trustDomain: "cluster.local"

  defaultConfig:
    proxyMetadata: {}
    tracing:
    #      tlsSettings:
    #        mode: DISABLE # DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
    #        clientCertificate: # example: /etc/istio/tracer/cert-chain.pem
    #        privateKey:        # example: /etc/istio/tracer/key.pem
    #        caCertificates:    # example: /etc/istio/tracer/root-cert.pem
    #        sni:               # example: tracer.somedomain
    #        subjectAltNames: []
    # - tracer.somedomain
